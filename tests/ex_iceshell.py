import multiprocessing as mp
import numpy as np
import time
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
import pickle
import os

import cal_gravitational_field_symmetry as cn
import cal_gravitational_field_glq as cg


def cal_glq(r_cal, delta, is_linear_density):
    '''
    Test gravitational field V, Vz, and Vzz
    generated by spherical shell. 
    '''
    script_dir = os.path.dirname(__file__) 
    relative_dir = f"data/thickness_{delta}_{delta}.csv"
    file_name = os.path.join(script_dir, relative_dir)
    thickness = np.loadtxt(file_name, delimiter=',')

    density = np.zeros((int(round(180/delta)), int(round(360/delta)))) + 1000
    if is_linear_density:
        density_gradient = np.zeros((int(round(180/delta)), int(round(360/delta)))) + 20 / 1000
    else:
        density_gradient = np.zeros((int(round(180/delta)), int(round(360/delta)))) + 0 / 1000
    
    r_min = np.zeros((int(round(180/delta)), int(round(360/delta)))) + 1728000
    r_max = r_min + thickness
    latitude_deg = np.arange(-90+delta/2, 90, int(round(delta)))
    longitude_deg = np.arange(-180+delta/2, 180, int(round(delta)))
    latitude = latitude_deg * np.pi / 180
    longitude = longitude_deg * np.pi / 180

    max_node = 3
    
    phi_min = -90 * np.pi / 180
    phi_max = 90 * np.pi / 180
    lambda_min = -180 * np.pi / 180
    lambda_max = np.pi

    tags = ['V', 'Vz', 'Vzz']

    if is_linear_density:
        temp1 = 'linear'
    else:
        temp1 = 'constant'

    for tag in tags:
        if tag=='V':
            ratio = 14
        elif tag=='Vz':
            ratio = 8
        else:
            ratio = 7
        
        c_time = time.time()
        gf = cg.cal_gravitational_field(r_cal, latitude, longitude, \
            r_min, r_max, phi_min, phi_max,  
            lambda_min, lambda_max, 
            density, density_gradient, 
            max_node, ratio, tag, is_linear_density,
            is_parallel_computing=True)
        run_time = time.time() - c_time

        relative_dir = f'data/{delta}_{delta}_{temp1}_{tag}_ice_shell_glq_{r_cal}.pkl'
        filename_dat = os.path.join(script_dir, relative_dir)
        with open(filename_dat, 'wb') as f:  
            pickle.dump([gf, run_time], f)


def cal_new(r_cal, delta, is_linear_density):
    '''
    Test gravitational field V, Vz, and Vzz
    generated by spherical shell. 
    '''
    script_dir = os.path.dirname(__file__) 
    relative_dir = f'data/thickness_{delta}_{delta}.csv'
    file_name = os.path.join(script_dir, relative_dir)
    thickness = np.loadtxt(file_name, delimiter=',')

    density = np.zeros((int(round(180/delta)), int(round(360/delta)))) + 1000
    if is_linear_density:
        density_gradient = np.zeros((int(round(180/delta)), int(round(360/delta)))) + 20 / 1000
    else:
        density_gradient = np.zeros((int(round(180/delta)), int(round(360/delta)))) + 0 / 1000

    r_min = np.zeros((int(round(180/delta)), int(round(360/delta)))) + 1728000
    r_max = r_min + thickness
    latitude_deg = np.arange(-90+delta/2, 90, int(round(delta)))
    longitude_deg = np.arange(-180+delta/2, 180, int(round(delta)))
    latitude = latitude_deg * np.pi / 180
    longitude = longitude_deg * np.pi / 180

    max_order_r_max = 4
    max_order_r_min = 0
    max_node = 3

    parts_num_r_max = 1
    parts_num_r_min = 1

    phi_min = -90 * np.pi / 180
    phi_max = 90 * np.pi / 180
    lambda_min = -180 * np.pi / 180
    lambda_max = np.pi

    tags = ['V', 'Vz', 'Vzz']
    if is_linear_density:
        temp1 = 'linear'
    else:
        temp1 = 'constant'

    for tag in tags:
        if tag=='V':
            ratio = 14
        elif tag=='Vz':
            ratio = 8
        else:
            ratio = 7

        c_time = time.time()
        gf = cn.cal_gravitational_field(r_cal, latitude, longitude, \
            r_min, r_max, phi_min, phi_max,  
            lambda_min, lambda_max, 
            density, density_gradient, max_order_r_max, max_order_r_min, 
            max_node, ratio, tag, 
            parts_num_r_max, parts_num_r_min,
            is_linear_density, is_parallel_computing=True)
        run_time = time.time() - c_time
        
        relative_dir = f'data/{delta}_{delta}_{temp1}_{tag}_ice_shell_new_order_{max_order_r_max}_{max_order_r_min}_parts_{parts_num_r_max}_{parts_num_r_min}_{r_cal}.pkl'
        filename_dat = os.path.join(script_dir, relative_dir)
        with open(filename_dat, 'wb') as f:  
            pickle.dump([gf, run_time], f)
    

if __name__ == '__main__':
    delta = 5
    r_cal = 1761358.0 + np.array([1, 100, 500, 1000, 5000, 10*1000, 50*1000, 100*1000])
    for r in r_cal:
        for is_linear_density in [True, False]:
            cal_glq(r, delta, is_linear_density)
            cal_new(r, delta, is_linear_density)
