import multiprocessing as mp
import numpy as np
import time
import matplotlib.pyplot as plt
from mpl_toolkits.axes_grid1 import make_axes_locatable
import pickle
import os

import cal_gravitational_field_symmetry as cn
import cal_gravitational_field_glq as cg


def cal_glq(r_cal, delta, is_linear_density):
    '''
    Calculate gravitational field V, Vz, and Vzz generated by spherical shell. 
    '''
    # set paramaters of spherical shell
    thickness = np.zeros((int(round(180/delta)), int(round(360/delta)))) + 10 * 1000
    density = np.zeros((int(round(180/delta)), int(round(360/delta)))) + 1000
    if is_linear_density:
        density_gradient = np.zeros((int(round(180/delta)), int(round(360/delta)))) + 20 / 1000
    else:
        density_gradient = np.zeros((int(round(180/delta)), int(round(360/delta)))) + 0 / 1000
    
    r_max = np.zeros((int(round(180/delta)), int(round(360/delta)))) + 1738000
    r_min = r_max - thickness
    latitude_deg = np.arange(-90+delta/2, 90, int(round(delta)))
    longitude_deg = np.arange(-180+delta/2, 180, int(round(delta)))
    latitude = latitude_deg * np.pi / 180
    longitude = longitude_deg * np.pi / 180

    max_node = 3
    
    phi_min = -90 * np.pi / 180
    phi_max = 90 * np.pi / 180
    lambda_min = -180 * np.pi / 180
    lambda_max = np.pi

    G = 6.67384e-11
    M = 4 / 3 * np.pi * ((np.mean(r_max))**3 - (np.mean(r_min))**3) \
        * (np.mean(density) - np.mean(density_gradient) * np.mean(r_min))
    
    tags = ['V', 'Vz', 'Vzz']
    run_time = [0, 0, 0]
    relative_error = []
    temp = 0
    if is_linear_density:
        temp1 = 'linear'
    else:
        temp1 = 'constant'

    for tag in tags:
        if tag=='V':
            ratio = 14
        elif tag=='Vz':
            ratio = 8
        else:
            ratio = 7
           
        c_time = time.time()
        aa = cg.cal_gravitational_field(r_cal, latitude, longitude, \
            r_min, r_max, phi_min, phi_max,  
            lambda_min, lambda_max, 
            density, density_gradient, 
            max_node, ratio, tag, is_linear_density,
            is_parallel_computing=True)
        run_time[temp] = time.time() - c_time
        if tag=='V':
            v = G * M / r_cal \
                + np.pi * G * np.mean(density_gradient) \
                / (r_cal) * ((np.mean(r_max))**4 - (np.mean(r_min))**4)
        elif tag=='Vz':
            v = -(G * M / r_cal**2 \
                + np.pi * G * np.mean(density_gradient) \
                / (r_cal**2) * ((np.mean(r_max))**4 - (np.mean(r_min))**4))
        else:
            v = 2 * G * M / r_cal**3 \
                + 2 * np.pi * G * np.mean(density_gradient) \
                / (r_cal**3) * ((np.mean(r_max))**4 - (np.mean(r_min))**4)
        
        relative_error.append((v - aa) / v)
        
        print('The relative error of ' + tag + ' is ' + str(np.mean(np.abs(relative_error[temp]))) + '.')
        print('Computational time of ' + tag + ' is ' + str(run_time[temp]) + 's.')
        
        temp += 1
    # write result to file
    script_dir = os.path.dirname(__file__) 
    filename_dat = os.path.join(script_dir, f'data/{delta}_{delta}_{temp1}_spherical_shell_glq_{r_cal}.pkl')
    with open(filename_dat, 'wb') as f:  
        pickle.dump([relative_error, run_time], f)


def cal_new(r_cal, delta, is_linear_density):
    '''
    Use symmetry to calculate the gravitational field V, Vz, and Vzz of spherical shell. 
    '''
    thickness = np.zeros((int(round(180/delta)), int(round(360/delta)))) + 10 * 1000
    density = np.zeros((int(round(180/delta)), int(round(360/delta)))) + 1000
    if is_linear_density:
        density_gradient = np.zeros((int(round(180/delta)), int(round(360/delta)))) + 20 / 1000
    else:
        density_gradient = np.zeros((int(round(180/delta)), int(round(360/delta)))) + 0 / 1000
    
    r_max = np.zeros((int(round(180/delta)), int(round(360/delta)))) + 1738000
    r_min = r_max - thickness
    latitude_deg = np.arange(-90+delta/2, 90, int(round(delta)))
    longitude_deg = np.arange(-180+delta/2, 180, int(round(delta)))
    latitude = latitude_deg * np.pi / 180
    longitude = longitude_deg * np.pi / 180

    max_order_r_max = 0
    max_order_r_min = 0
    max_node = 3
    
    parts_num_r_max = 1
    parts_num_r_min = 1

    phi_min = -90 * np.pi / 180
    phi_max = 90 * np.pi / 180
    lambda_min = -180 * np.pi / 180
    lambda_max = np.pi

    G = 6.67384e-11
    M = 4 / 3 * np.pi * ((np.mean(r_max))**3 - (np.mean(r_min))**3) \
        * (np.mean(density) - np.mean(density_gradient) * np.mean(r_min))
    
    tags = ['V', 'Vz', 'Vzz']
    
    temp = 0
    run_time = [0, 0, 0]
    relative_error = []
    if is_linear_density:
        temp1 = 'linear'
    else:
        temp1 = 'constant'

    for tag in tags:
        if tag=='V':
            ratio = 14
        elif tag=='Vz':
            ratio = 8
        else:
            ratio = 7

        c_time = time.time()
        aa = cn.cal_gravitational_field(r_cal, latitude, longitude, \
            r_min, r_max, phi_min, phi_max,  
            lambda_min, lambda_max, 
            density, density_gradient, max_order_r_max, max_order_r_min, 
            max_node, ratio, tag, 
            parts_num_r_max, parts_num_r_min,
            is_linear_density, is_parallel_computing=True)
        run_time[temp] = time.time() - c_time
        if tag=='V':
            v = G * M / r_cal \
                + np.pi * G * np.mean(density_gradient) \
                / (r_cal) * ((np.mean(r_max))**4 - (np.mean(r_min))**4)
        elif tag=='Vz':
            v = -(G * M / r_cal**2 \
                + np.pi * G * np.mean(density_gradient) \
                / (r_cal**2) * ((np.mean(r_max))**4 - (np.mean(r_min))**4))
        else:
            v = 2 * G * M / r_cal**3 \
                + 2 * np.pi * G * np.mean(density_gradient) \
                / (r_cal**3) * ((np.mean(r_max))**4 - (np.mean(r_min))**4)
        relative_error.append((v - aa) / v)
    
        print('The relative error of ' + tag + ' is ' + str(np.mean(np.abs(relative_error[temp]))) + '.')
        print('Computational time of ' + tag + ' is ' + str(run_time[temp]) + 's.')
        
        temp += 1
        
    script_dir = os.path.dirname(__file__) 
    relative_dir = f'data/{delta}_{delta}_{temp1}_spherical_shell_new_order_{max_order_r_max}_{max_order_r_min}_parts_{parts_num_r_max}_{parts_num_r_min}_{r_cal}.pkl'
    filename_dat = os.path.join(script_dir, relative_dir)
    with open(filename_dat, 'wb') as f:  
        pickle.dump([relative_error, run_time], f)


if __name__ == '__main__':
    r_cal = 1738000.0 + np.array([1, 100, 500, 1000, 5000, 10*1000, 50*1000, 100*1000])
    delta = 5
    for r in r_cal:
        for is_linear_density in [True, False]:
            cal_new(r, delta, is_linear_density)
            cal_glq(r, delta, is_linear_density)
        
